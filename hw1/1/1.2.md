## A - commands
### 1. create container root filesystem

create parent folder to act as `/` for our process in its namespace

```bash
mkdir -p mycontainer2/{bin,proc}
cp /usr/bin/busybox mycontainer2/bin/
cd mycontainer2/bin
ln -s busybox sh
ln -s busybox ls
ln -s busybox ps
ln -s busybox echo
ln -s busybox sleep
cd -
```

### 2. create a dedicated cgroup (cgroup v2)
```bash
mkdir /sys/fs/cgroup/mycontainer2-cgroup
cd /sys/fs/cgroup/mycontainer2-cgroup
```

apply resource limits:

```bash
echo 64 > pids.max                     # max 64 processes
echo $((256*1024*1024)) > memory.max   # 256 MB memory limit
echo "50000 100000" > cpu.max          # CPU = 50% of one core
```


move the current shell into the cgroup:

```bash
echo $$ > cgroup.procs

```


### 3. Enter isolated namespaces (Process B)
```bash
unshare --pid --uts --ipc --mount --fork --mount-proc bash
```
inside this new bash ----> It is PID 1 in the new PID namespace.


### 4. mount /proc for the PID namespace

```bash
mount -t proc none mycontainer2/proc
```

### 5. enter the container root filesystem (Process C)
```bash
chroot /home/sina/Desktop/kubernetes-course/hw1/1/mycontainer2 /bin/sh
```


### 6. test 

new rootfs:

```bash
/ # echo $$
/ # ps
/ # ls /

```

cgroup PID limit:

```bash
for i in $(seq 1 200); do sleep 99 & done
```

( this attempts to spawn 200 long-lived processes )

what we must see: `/bin/sh: can't fork: Resource temporarily unavailable`



```bash
cat pids.current
```
must return 64 as we modified in `pids.max`

---


## B - my notes

### Stage 0 — What is a container here?

CONTAINER = NAMESPACES + FILESYSTEM + PROCESS + /cgroups ( how many resources the process can use )

`BusyBox`  ---->  a tiny shell + tools with no dependencies.

symlinks (`sh`, `ls`, `ps`) let BusyBox act like multiple commands


---

### Stage 2 — cgroup v2

create a directory under:
```bash
/sys/fs/cgroup/mycontainer2-cgroup
```
-----> the container’s resource limits


when 
```bash
echo $$ > cgroup.procs
```
We move *this shell* into the cgroup

each process created from this shell ------> inherits this cgroup automatically




