

## A - Commands

## 1. Create container root filesystem

Create the parent folder to act as `/` for the process inside its namespace:

```bash
mkdir -p /any-path/mycontainer2/{bin,proc}
cp /usr/bin/busybox /any-path/mycontainer2/bin/
cd /any-path/mycontainer2/bin
ln -s busybox sh
ln -s busybox ls
ln -s busybox ps
ln -s busybox echo
ln -s busybox sleep
cd -
```

---

## 2. Create a dedicated cgroup (cgroup v2)

Create the container’s cgroup:

```bash
mkdir /sys/fs/cgroup/mycontainer2-cgroup
cd /sys/fs/cgroup/mycontainer2-cgroup
```

Apply resource limits:

```bash
echo 64 > pids.max                     # max 64 processes
echo $((256*1024*1024)) > memory.max   # 256 MB memory limit
echo "50000 100000" > cpu.max          # CPU = 50% of one core
```

Move the **correct shell** into the cgroup (done *after* entering namespaces):

```bash
echo $$ > cgroup.procs
```

> ✔ NOTE: This must be executed **inside the unshare shell**,  
> not before it — to ensure PID‑1 of the namespace belongs to this cgroup.

---

## 3. Enter isolated namespaces (Process B)

```bash
unshare --pid --uts --ipc --mount --fork --mount-proc bash
```

Inside this new `bash`, you are **PID 1** in the new PID namespace.

Now move *this* shell into the cgroup:

```bash
echo $$ > /sys/fs/cgroup/mycontainer2-cgroup/cgroup.procs
```

---

## 4. Mount `/proc` for the PID namespace

```bash
mount -t proc none /any-path/mycontainer2/proc
```

---

## 5. Enter the container root filesystem (Process C)

```bash
chroot /any-path/mycontainer2 /bin/sh
```

---

## 6. Test

Inside the new rootfs:

```bash
/ # echo $$
/ # ps
/ # ls /
```

---

### Test cgroup PID limit:

```bash
for i in $(seq 1 200); do sleep 99 & done
```

This attempts to spawn 200 long-lived processes.

Expected:

```
/bin/sh: can't fork: Resource temporarily unavailable
```

Now check:

```bash
cat /sys/fs/cgroup/mycontainer2-cgroup/pids.current
```

Must return **64**, as defined in `pids.max`.

---

## B - My Notes

### Stage 0 — What is a container here?

A **container** =  
**Namespaces** + **Filesystem** + **Process** + **cgroups** (resource limits)

BusyBox → a tiny shell + tools with no dependencies.  
Symlinks (`sh`, `ls`, `ps`) allow BusyBox to behave like multiple commands.

---

### Stage 2 — cgroup v2

Create a directory under:

```bash
/sys/fs/cgroup/mycontainer2-cgroup
```

→ This becomes the container’s resource-control group.

When running:

```bash
echo $$ > cgroup.procs
```

We move *this shell* into the cgroup.  
All child processes automatically inherit this cgroup assignment.

---

# ✔ End of document
