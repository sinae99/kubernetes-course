
### 1. create container rootfs
```bash
mkdir -p mycontainer/{bin,proc}
cp /usr/bin/busybox mycontainer/bin/
cd mycontainer/bin
ln -s busybox sh
ln -s busybox ls
ln -s busybox ps
ln -s busybox echo
cd -
```

### 2. enter isolated namespaces
```bash
sudo unshare --pid --uts --ipc --mount --fork --mount-proc bash
```

### 3. mount /proc for the container
```bash
mount -t proc none mycontainer/proc
```

### 4. enter container filesystem
```bash
chroot mycontainer /bin/sh
```

### 5. test
```
/ # ls
/ # echo $$
/ # ps
/ # hostname sag
```

---


### Stage 1 — why create root fs ?
a container = filesystem + executed program
BusyBox is a tiny shell + tools with no dependencies. 
symlinks (`sh`, `ls`, `ps`) let BusyBox act like multiple commands




### Stage 2 — unshare
```bash
sudo unshare --pid --uts --ipc --mount --fork --mount-proc bash
```
This creates new namespaces:
- **PID** → isolated process IDs  
- **UTS** → own hostname  
- **IPC** → isolated IPC objects  
- **Mount** → private mount table  
- **mount-proc** → new `/proc` matching this PID namespace  

The new `bash` becomes **PID 1** inside this new world.

### Stage 3 — /proc?
new PID namespace needs its own `/proc`, otherwise `ps` would show `host` processes.

### Stage 4 — chroot + /bin/sh
`bash` (PID1) still sees the *host* filesystem.  
to enter our container filesystem :

```bash
chroot mycontainer /bin/sh
```

this launches a new process **inside the container filesystem**.

Inside:
- `bash` = PID1, parent, manages namespace  
- `sh`   = child process inside container rootfs  

### Stage 5 — What each process sees

| Process | Namespaces | Filesystem | PID inside ns |
|---------|------------|------------|----------------|
| `bash` (PID1) | new PID/UTS/IPC/MNT | host FS | 1 |
| `sh` (chroot) | same namespaces | mycontainer/ | sth like 9 |

This is a real minimal container:  
isolated PIDs, isolated `/proc`, isolated FS root, own hostname.

---



