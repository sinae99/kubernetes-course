# HW1.1 – Minimal Container with Namespaces + chroot

## Part 1 — Commands (quick path)

### 1. Create container rootfs
```bash
mkdir -p mycontainer/{bin,proc}
cp /usr/bin/busybox mycontainer/bin/
cd mycontainer/bin
ln -s busybox sh
ln -s busybox ls
ln -s busybox ps
ln -s busybox echo
cd -
```

### 2. Enter isolated namespaces
```bash
sudo unshare --pid --uts --ipc --mount --fork --mount-proc bash
```

### 3. Mount /proc for the container
```bash
mount -t proc none mycontainer/proc
```

### 4. Enter container filesystem
```bash
chroot mycontainer /bin/sh
```

### 5. Test
```
/ # ls
/ # echo $$
/ # ps
/ # hostname sag
```

---

## Part 2 — Explanation (short + clear)

<<<<<<< HEAD
### Stage 1 — Why create mycontainer/ rootfs?
A container needs its own filesystem.  
BusyBox gives us a tiny shell + tools with no dependencies.  
Symlinks (`sh`, `ls`, `ps`) let BusyBox act like multiple programs.
=======

### this is my first container !

---


### ( optional - another container with more namespaces ) :


create a more isolated container using multiple namespaces (MNT, PID, UTS, IPC, New /proc) :


#### start the namespace stack:

```bash
sudo unshare --mount --pid --uts --ipc --fork bash
```
right now im just ====> **a process inside 4 namespaces (mnt, pid, uts, ipc)**

#### give this namespace a new hostname:

```bash
hostname container2
```

#### make mount propagation private :

```bash
mount --make-rprivate /
```

#### mount /proc for the PID namespace :

```bash
mount -t proc proc rootfs/proc
```
because -----> process will expect `/proc` inside the container


#### enter the rootfs using `chroot` :

```bash
sudo chroot rootfs /sh
```

right now im just ====> **a process inside multiple namespaces with its own `/`, own hostname, own PID 1, own `/proc`**





inside container:
```test
/ # hostname
container2

/ # ps
PID   COMMAND
1     sh
```

### this is my second container !













>>>>>>> 4a419b6e062802b9bb2415080283b8a4c2473fdc

### Stage 2 — What does unshare do?
```bash
sudo unshare --pid --uts --ipc --mount --fork --mount-proc bash
```
This creates new namespaces:
- **PID** → isolated process IDs  
- **UTS** → own hostname  
- **IPC** → isolated IPC objects  
- **Mount** → private mount table  
- **mount-proc** → new `/proc` matching this PID namespace  

The new `bash` becomes **PID 1** inside this new world.

### Stage 3 — Why mount /proc?
The new PID namespace needs its own `/proc`, otherwise `ps` would show host processes.

### Stage 4 — Why chroot and why /bin/sh?
`bash` (PID1) still sees the *host* filesystem.  
To enter our container filesystem we run:

```bash
chroot mycontainer /bin/sh
```

This launches a new process **inside the container filesystem**.

Inside:
- `bash` = PID1, parent, manages namespace  
- `sh`   = child process inside container rootfs  

### Stage 5 — What each process sees

| Process | Namespaces | Filesystem | PID inside ns |
|---------|------------|------------|----------------|
| `bash` (PID1) | new PID/UTS/IPC/MNT | host FS | 1 |
| `sh` (chroot) | same namespaces | mycontainer/ | e.g., 9 |

This is a real minimal container:  
isolated PIDs, isolated `/proc`, isolated FS root, own hostname.

---

## Final Summary
You built a container by combining:
- `unshare` → namespaces  
- `chroot` → filesystem isolation  
- `busybox` → program inside container  
- new `/proc` → correct process view  

Exactly how Docker builds containers internally, but manually.

