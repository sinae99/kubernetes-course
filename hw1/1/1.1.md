
### 1. create container rootfs
```bash
mkdir -p mycontainer1/{bin,proc}
cp /usr/bin/busybox mycontainer1/bin/
cd mycontainer/bin
ln -s busybox sh
ln -s busybox ls
ln -s busybox ps
ln -s busybox echo
cd -
```

### 2. enter isolated namespaces
```bash
sudo unshare --pid --uts --ipc --mount --fork --mount-proc bash
```

### 3. mount /proc for the container
```bash
mount -t proc none mycontainer1/proc
```

### 4. enter container filesystem
```bash
chroot mycontainer1 /bin/sh
```

### 5. test
```
/ # ls
/ # echo $$
/ # ps
/ # hostname sag
```

---


### Stage 1 — Why create mycontainer1/ rootfs?
A container needs its own filesystem.  
BusyBox gives us a tiny shell + tools with no dependencies.  
Symlinks (`sh`, `ls`, `ps`) let BusyBox act like multiple programs.




### Stage 2 — What does unshare do?
```bash
sudo unshare --pid --uts --ipc --mount --fork --mount-proc bash
```
This creates new namespaces:
- **PID** → isolated process IDs  
- **UTS** → own hostname  
- **IPC** → isolated IPC objects  
- **Mount** → private mount table  
- **mount-proc** → new `/proc` matching this PID namespace  

The new `bash` becomes **PID 1** inside this new world.

### Stage 3 — Why mount /proc?
The new PID namespace needs its own `/proc`, otherwise `ps` would show host processes.

### Stage 4 — Why chroot and why /bin/sh?
`bash` (PID1) still sees the *host* filesystem.  
To enter our container filesystem we run:

```bash
chroot mycontainer1 /bin/sh
```

This launches a new process **inside the container filesystem**.

Inside:
- `bash` = PID1, parent, manages namespace  
- `sh`   = child process inside container rootfs  

### Stage 5 — What each process sees

| Process | Namespaces | Filesystem | PID inside ns |
|---------|------------|------------|----------------|
| `bash` (PID1) | new PID/UTS/IPC/MNT | host FS | 1 |
| `sh` (chroot) | same namespaces | mycontainer1/ | sth like 9 |

This is a real minimal container:  
isolated PIDs, isolated `/proc`, isolated FS root, own hostname.

---



